<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python标准库-os模块</title>
      <link href="/2021/03/01/Python%E6%A0%87%E5%87%86%E5%BA%93-os%E6%A8%A1%E5%9D%97/"/>
      <url>/2021/03/01/Python%E6%A0%87%E5%87%86%E5%BA%93-os%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Python标准库中的os模块，提供了许多与操作系统相关联的函数，其中最常用的就是对文件的操作：</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">os.getcwd()</td><td>获取当前python脚本的工作目录路径</td></tr><tr><td style="text-align:left">os.mkdir(‘dirname’)</td><td>生成单级目录</td></tr><tr><td style="text-align:left">os.makedirs(‘dirname1/dirname2’)</td><td>生成多层递归目录</td></tr><tr><td style="text-align:left">os.listdir(‘dirname’)</td><td>列出指定目录下所有的文件和子目录</td></tr><tr><td style="text-align:left">os.dirname(path)</td><td>返回path的目录</td></tr><tr><td style="text-align:left">os.basename(path)</td><td>返回path最后的文件名</td></tr><tr><td style="text-align:left">os.path.exists(path)</td><td>若path存在，返回True，否则返回False</td></tr><tr><td style="text-align:left">os.path.isfile(path)</td><td>若path是一个存在的文件，返回True，否则返回False</td></tr><tr><td style="text-align:left">os.path.isdir(path)</td><td>若path是一个存在的目录，返回True，否则返回False</td></tr><tr><td style="text-align:left">os.path.join(path1[, path2[, …]])</td><td>将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</td></tr><tr><td style="text-align:left">os.path.abspath(path)</td><td>返回path规范化的绝对路径</td></tr></tbody></table></div><p>这里我们提供一个具体的示例，该示例不仅展示了os模块的用法，也涉及到了绝对路径，相对路径，工作路径的概念。</p><p>先简单介绍一下绝对路径与相对路径的区别，绝对路径是从磁盘根目录开始的完整路径，而相对路径是相对于某个文件目录的路径，为了形象解释，我们创建以下结构的项目文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path_project</span><br><span class="line">├── dir</span><br><span class="line">│   ├── data.txt</span><br><span class="line">│   └── test2.py</span><br><span class="line">└── test1.py</span><br></pre></td></tr></table></figure><p>其中path_project的绝对路径为：’/Users/yihaosun/path_project’，在test2.py定义了一个读取data.txt的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span>():</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;./data.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">read_data()</span><br></pre></td></tr></table></figure><p>这里的’./data.txt’便是相对路径，<strong>‘.’代表是启程程序的命令执行时所在的目录</strong>，具体来说，如果在dir下直接执行python test2.py，‘.’就代表了’/Users/yihaosun/path_project/dir’；如果我们在test1.py里面import read_data函数并调用，再在path_project下执行python test1.py，此时’.’则表示‘/Users/yihaosun/path_project’；或者我们在path_project路径下，执行python dir/test2.py，那么’.’表示的也是‘/Users/yihaosun/path_project’。</p><p>所以我们在dir下执行python test2.py，会成功读取到data.txt，而如果在path_projet下执行python test1.py，则会报错，因为在path_project目录下没有data.txt，在path_project下执行python dir/test2.py同样也会报错，下面开始验证：</p><p>dir路径下运行test2.py：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yihaosun @ YihaodeMacBook-Pro <span class="keyword">in</span> ~/path_project/dir [14:50:23]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python test2.py</span></span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure><p>编写test1.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dir.test2 <span class="keyword">import</span> read_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">read_data()</span><br></pre></td></tr></table></figure><p>path_project下分别运行test1.py和test2.py:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yihaosun @ YihaodeMacBook-Pro <span class="keyword">in</span> ~/path_project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python test1.py</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test1.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    read_data()</span><br><span class="line">  File &quot;/Users/yihaosun/path_project/dir/test2.py&quot;, line 2, in read_data</span><br><span class="line">    with open(&#x27;./data.txt&#x27;) as f:</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#x27;./data.txt&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> yihaosun @ YihaodeMacBook-Pro <span class="keyword">in</span> ~/path_project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python dir/test2.py</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;dir/test2.py&quot;, line 6, in &lt;module&gt;</span><br><span class="line">    read_data()</span><br><span class="line">  File &quot;dir/test2.py&quot;, line 2, in read_data</span><br><span class="line">    with open(&#x27;./data.txt&#x27;) as f:</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#x27;./data.txt&#x27;</span><br></pre></td></tr></table></figure><p>实验结果印证了我们的想法，如果想解决上述问题，让test1.py和test2.py再各种路径下都能成功运行，我们需要在read_data里面定义data.txt的绝对路径，对test2.py修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span>():</span></span><br><span class="line">file_path = os.path.abspath(__file__)  <span class="comment"># 先通过abspath方法获取当前脚本的绝对路径，__file__表示定义这个函数的文件（test2.py）的绝对路径</span></span><br><span class="line">print(file_path)</span><br><span class="line">file_path = os.path.dirname(file_path)  <span class="comment"># 获取当前路径的目录</span></span><br><span class="line"><span class="keyword">with</span> open(os.path.join(file_path, <span class="string">&#x27;data.txt&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">read_data()</span><br></pre></td></tr></table></figure><p>再次在path_project下运行test1.py和test2.py:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yihaosun @ YihaodeMacBook-Pro <span class="keyword">in</span> ~/path_project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python test1.py</span></span><br><span class="line">/Users/yihaosun/path_project/dir/test2.py</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> yihaosun @ YihaodeMacBook-Pro <span class="keyword">in</span> ~/path_project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python dir/test2.py</span></span><br><span class="line">/Users/yihaosun/path_project/dir/test2.py</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy简易教程</title>
      <link href="/2021/02/28/NumPy%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
      <url>/2021/02/28/NumPy%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="NumPy简介"><a href="#NumPy简介" class="headerlink" title="NumPy简介"></a>NumPy简介</h2><p>NumPy是Python中科学计算的基础包。它是一个Python库，提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。</p><p>Numpy包的核心是ndarray对象，对比与原生的Python Array，主要区别有：</p><ul><li>NumPy数组在创建时有固定的大小，而Python Array可以动态增长。所以更改ndarray的大小将创建一个新数组并删除原来的数组。</li><li>NumPy数组中的元素需要具有相同的数据类型，因此在内存中的大小相同，而Python Array可以允许元素不同类型。</li><li>NumPy数组可以方便的进行高级数学运算，相较于Python Array，通常具有更高的执行效率（使用了预编译的C代码）和更简练的编写（几乎没有任何的显示循环，索引等）。</li></ul><h2 id="1-NumPy数组属性"><a href="#1-NumPy数组属性" class="headerlink" title="1 NumPy数组属性"></a>1 NumPy数组属性</h2><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>ndarray.data</td><td>实际数组元素</td></tr><tr><td>ndarray.shape</td><td>数组维度，例如对于矩阵，n行m列，shape=(n, m)</td></tr><tr><td>ndarray.dtype</td><td>数组元素的数据类型</td></tr><tr><td>ndarray.ndim</td><td>维度的数量，即维度元组的长度：len(shape)，例如对于矩阵，ndim=2</td></tr></tbody></table></div><h2 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2 创建数组"></a>2 创建数组</h2><p>我们可以通过显式的指定数组（Python Array）来创建一个ndarray对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array(data=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 省略dtype属性时，dtype根据data自动确定</span></span><br></pre></td></tr></table></figure><p>也可以快速创建由特殊值构成的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建维度为（1，2）即一行两列的全0数组</span></span><br><span class="line">zeros_array = np.zeros(shape=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 创建维度为（3，4）即三行四列的全1数组</span></span><br><span class="line">ones_array = np.ones(shape=(<span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>创建指定分布的随机数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数原型：numpy.random.normal(loc,scale,size)</span></span><br><span class="line"><span class="comment"># 创建均值为0，标准差为1的正态分布的随机数组</span></span><br><span class="line">normal_array = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数原型：numpy.random.uniform(low,high,size)</span></span><br><span class="line"><span class="comment"># 创建[0,5)的均匀分布的随机数组</span></span><br><span class="line">uniform_array = np.random.uniform(<span class="number">0</span>, <span class="number">5</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h2 id="3-索引与切片"><a href="#3-索引与切片" class="headerlink" title="3 索引与切片"></a>3 索引与切片</h2><p>Numpy的索引与Python中的list类似，通过[]来进行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问第2行第3列的数据 通过‘,’区分各个维度</span></span><br><span class="line">print(a[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问第3列的1-2行数据 通过&#x27;:&#x27;来切片(用法：start:stop:step，[start,stop)，即不包括stop索引，step为1时可省略)</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问第3列，第2行以后的所有行（包括第二行）的数据</span></span><br><span class="line">print(a[<span class="number">1</span>:, <span class="number">2</span>]) <span class="comment"># start: 代表从start索引开始后面所有的项都被提取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问第三列全部数据</span></span><br><span class="line">print(a[:, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过&#x27;...&#x27;来使选择元组的长度与数组的维度相同，示例：</span></span><br><span class="line">a = np.array([[[<span class="number">1</span>, <span class="number">11</span>], [<span class="number">2</span>, <span class="number">22</span>], [<span class="number">3</span>, <span class="number">33</span>]], [[<span class="number">4</span>, <span class="number">44</span>], [<span class="number">5</span>, <span class="number">55</span>], [<span class="number">6</span>, <span class="number">66</span>]]]) <span class="comment"># shape=(2, 3, 2)</span></span><br><span class="line">print(a[..., <span class="number">0</span>])</span><br><span class="line">out: [[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]] <span class="comment"># 其结果等价于a[:, :, 0]</span></span><br></pre></td></tr></table></figure><p>NumPy还可以通过布尔数组进行索引来达到条件过滤的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选出大于5的元素</span></span><br><span class="line">print(a[a &gt; <span class="number">5</span>])</span><br><span class="line">out: [<span class="number">6</span> <span class="number">7</span> <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">a = np.array([np.nan, <span class="number">1</span>, <span class="number">2</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 过滤掉NaN</span></span><br><span class="line"><span class="keyword">print</span> (a[~np.isnan(a)])</span><br><span class="line">out: [<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span>]</span><br></pre></td></tr></table></figure><h2 id="4-数组操作"><a href="#4-数组操作" class="headerlink" title="4 数组操作"></a>4 数组操作</h2><p>首先常用的操作是修改数组维度（更改shape但是ndim不变），这可以依靠<strong>reshape，numpy.expand_dims，numpy.squeeze</strong>实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arrange(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 将0-9的一维数组变成(3,3)的矩阵</span></span><br><span class="line">a = a.reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组增加一维</span></span><br><span class="line"><span class="comment"># 函数原型：numpy.expand_dims(arr, axis)</span></span><br><span class="line">b = np.expand_dims(a, axis=<span class="number">0</span>)</span><br><span class="line">out: [[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]], shape=(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数组降低一维</span></span><br><span class="line"><span class="comment"># 函数原型：numpy.squeeze(arr, axis)</span></span><br><span class="line">a = np.squeeze(b, axis=<span class="number">0</span>)</span><br><span class="line">out: [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>], shape=(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>拼接多个数组也是常见的操作之一，最常用的函数是numpy.concatenate：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a1 = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">a2 = np.array([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数原型：numpy.concatenate((a1, a2, ...), axis)</span></span><br><span class="line"><span class="comment"># 将a1,a2沿着轴0拼接在一起</span></span><br><span class="line">b = np.concatenate((a1, a2), axis=<span class="number">0</span>)</span><br><span class="line">out: [[<span class="number">0</span> <span class="number">1</span>] </span><br><span class="line">      [<span class="number">2</span> <span class="number">3</span>] </span><br><span class="line">      [<span class="number">4</span> <span class="number">5</span>] </span><br><span class="line">      [<span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将a1, a2沿着轴1拼接在一起</span></span><br><span class="line">b = np.concatenate((a1, a2), axis=<span class="number">1</span>)</span><br><span class="line">out: [[<span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span>] </span><br><span class="line">  [<span class="number">2</span> <span class="number">3</span> <span class="number">6</span> <span class="number">7</span>]]</span><br></pre></td></tr></table></figure><p><strong>可以观察到，只有数组的shape一样时才可以进行拼接，并且拼接完成后ndim不变。</strong></p><h2 id="5-统计函数"><a href="#5-统计函数" class="headerlink" title="5 统计函数"></a>5 统计函数</h2><p>最小/大值，平均值，标准差/方差，求和，乘积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小值</span></span><br><span class="line">print(a.min()) <span class="comment"># 也可以使用np.min(a)</span></span><br><span class="line">out: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大值</span></span><br><span class="line">print(a.max())</span><br><span class="line">out: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 平均值</span></span><br><span class="line">print(a.mean())</span><br><span class="line">out: <span class="number">1.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准差</span></span><br><span class="line">print(a.std())</span><br><span class="line">out: <span class="number">1.118033988749895</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方差</span></span><br><span class="line">print(a.var())</span><br><span class="line">out: <span class="number">1.25</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求和</span></span><br><span class="line">print(a.sum())</span><br><span class="line">out: <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘积</span></span><br><span class="line">print(a.prod())</span><br><span class="line">out: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>横跨某一维度进行统计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每列最小值，统计列最小即为跨行选取最小值，所以axis=0</span></span><br><span class="line">print(a.min(axis=<span class="number">0</span>))</span><br><span class="line">out: [<span class="number">2</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每行最小值，统计行最小即为跨列选取最小值，所以axis=1</span></span><br><span class="line">print(a.min(axis=<span class="number">1</span>))</span><br><span class="line">out: [<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若想统计前后数组维度数量保持不变，可以设置keepdims=True</span></span><br><span class="line">print(a.min(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line">out: [[<span class="number">1</span>]</span><br><span class="line">      [<span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>输出最值索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每列的最大值元素的索引</span></span><br><span class="line">print(a.argmax(axis=<span class="number">0</span>))</span><br><span class="line">out: [<span class="number">0</span> <span class="number">1</span>] <span class="comment"># 第一列最大元素为3，在第一行，所以行索引为0，同理第二列最大值4行索引为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每行最小值元素的索引</span></span><br><span class="line">print(a.argmin(axis=<span class="number">1</span>))</span><br><span class="line">out: [<span class="number">1</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">3</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数原型: numpy.sort(a, axis, kind, order)</span></span><br><span class="line"><span class="comment"># a: 要排序的数组</span></span><br><span class="line"><span class="comment"># axis: 沿着它排序数组的轴，0表示按行，1表示按列，None表示展开来排序，默认值为-1，表示沿最后的轴排序</span></span><br><span class="line"><span class="comment"># kind: 默认为&#x27;quicksort&#x27;，还可选择&#x27;mergesort&#x27;，‘heapsort’</span></span><br><span class="line"><span class="comment"># order: 如果数组包含字段，则是要排序的字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列排序</span></span><br><span class="line">print(np.sort(a, axis=<span class="number">0</span>))</span><br><span class="line">out: [[<span class="number">2</span> <span class="number">1</span>]</span><br><span class="line">      [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># np.sort默认升序排序，若想倒序排序，可使用如下技巧</span></span><br><span class="line">print(-np.sort(-a, axis=<span class="number">0</span>))</span><br><span class="line">out: [[<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">      [<span class="number">2</span> <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照指定字段排序</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;name&#x27;</span>,  <span class="string">&#x27;S10&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,  int)]) </span><br><span class="line">a = np.array([(<span class="string">&quot;raju&quot;</span>,<span class="number">21</span>),(<span class="string">&quot;anil&quot;</span>,<span class="number">25</span>),(<span class="string">&quot;ravi&quot;</span>,  <span class="number">17</span>),  (<span class="string">&quot;amar&quot;</span>,<span class="number">27</span>)], dtype = dt)</span><br><span class="line">print(np.sort(a, order=<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line">out: [(<span class="string">b&#x27;amar&#x27;</span>, <span class="number">27</span>) (<span class="string">b&#x27;anil&#x27;</span>, <span class="number">25</span>) (<span class="string">b&#x27;raju&#x27;</span>, <span class="number">21</span>) (<span class="string">b&#x27;ravi&#x27;</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure><p>普通排序是从小到大输出每个元素，此外我们还可以输出排序索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">print(np.argsort(a))</span><br><span class="line">out: [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>] <span class="comment"># 最小的元素为1，索引为1，第二小的元素为2，索引为2，最大的元素为3，索引值为0</span></span><br></pre></td></tr></table></figure><h2 id="6-Numpy数学运算"><a href="#6-Numpy数学运算" class="headerlink" title="6 Numpy数学运算"></a>6 Numpy数学运算</h2><p>加减乘除，次方基本运算符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加减乘除时对应位置元素进行加减乘除</span></span><br><span class="line">print(a + b)</span><br><span class="line">out: [[<span class="number">4</span> <span class="number">6</span>]</span><br><span class="line">      [<span class="number">8</span> <span class="number">10</span>]]</span><br><span class="line"></span><br><span class="line">print(a - b)</span><br><span class="line">out: [[<span class="number">-4</span> <span class="number">-4</span>]</span><br><span class="line">      [<span class="number">-4</span> <span class="number">-4</span>]]</span><br><span class="line"></span><br><span class="line">print(a * b)</span><br><span class="line">out: [[<span class="number">0</span> <span class="number">5</span>]</span><br><span class="line">      [<span class="number">12</span> <span class="number">21</span>]]</span><br><span class="line"></span><br><span class="line">print(a / b)</span><br><span class="line">out: [[<span class="number">0.</span>          <span class="number">0.2</span>       ]</span><br><span class="line">      [<span class="number">0.33333333</span>, <span class="number">0.42857143</span>]]</span><br><span class="line">      </span><br><span class="line">print(a ** <span class="number">2</span>)</span><br><span class="line">out: [[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">      [<span class="number">4</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p>线性代数运算（点积，矩阵乘积，行列式，矩阵转置，矩阵求逆）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点积, 一维为向量内积，二维时计算的是矩阵乘积，多维时结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和：dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</span></span><br><span class="line">print(np.dot(a, b))</span><br><span class="line">out: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘积可以使用上述的np.dot，也可以使用np.matmul</span></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">b = np.array([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">print(np.matmul(a, b))</span><br><span class="line">out: [[<span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">      [<span class="number">26</span> <span class="number">31</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行列式</span></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">print(np.linalg.det(a))</span><br><span class="line">out: <span class="number">-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵转置</span></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">print(np.transpose(a))</span><br><span class="line">out: [[<span class="number">0</span> <span class="number">2</span>]</span><br><span class="line">      [<span class="number">1</span> <span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵求逆</span></span><br><span class="line">a = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">print(np.linalg.inv(a))</span><br><span class="line">out: [[<span class="number">-1.5</span> <span class="number">0.5</span>]</span><br><span class="line">      [<span class="number">1</span>    <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接创建矩阵对象可以简化运算符号</span></span><br><span class="line">A = np.matrix([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">B = np.matrix([[<span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">print(A * B) <span class="comment"># 矩阵乘积</span></span><br><span class="line">print(A.T) <span class="comment"># 转置</span></span><br><span class="line">print(A.I) <span class="comment"># 逆</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NumPy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deterministic Policy Gradient (DPG)</title>
      <link href="/2021/02/15/Deterministic-Policy-Gradient-DPG/"/>
      <url>/2021/02/15/Deterministic-Policy-Gradient-DPG/</url>
      
        <content type="html"><![CDATA[<p><a href="">Paper Link</a></p><p>Deterministic Policy Gradient (DPG) is a special policy gradient method which can solve the tasks with deterministic policies.  DPG has an appealing form : it is the expected gradient of the action-value function. This simple form means that the deterministic gradient can be estimated much more efficiently than the usual stochastic policy gradient.</p><h3 id="Stochastic-Actor-Critic-Algorithms"><a href="#Stochastic-Actor-Critic-Algorithms" class="headerlink" title="Stochastic Actor-Critic Algorithms"></a>Stochastic Actor-Critic Algorithms</h3><p>We first review traditional stochastic actor-critic algorithms, including on-policy actor-critic and off-policy actor-critic.</p><h4 id="On-Policy-Actor-Critic"><a href="#On-Policy-Actor-Critic" class="headerlink" title="On-Policy Actor-Critic"></a>On-Policy Actor-Critic</h4><p>According to the policy gradient theorem, we can compute the gradient of the current policy $\pi_\theta$ as follows:</p><script type="math/tex; mode=display">\bigtriangledown_{\theta}J(\pi_{\theta}) = E_{s \sim \rho^{\pi_\theta} , a \sim \pi_\theta} \left[\bigtriangledown_{\theta}log\pi_{\theta}(a|s)Q^{\omega}(s, a)\right].\tag{1}</script><p>This equation consists of two estimator:  policy estimator $\pi_{\theta}$ and action-value estimator $Q^{\omega}$. The policy estimator is referred to as actor and the update of its parameters follow $\bigtriangledown_{\theta}J(\pi_{\theta})$, while the action-value estimator is  referred as critic and the update of its parameters follow $\bigtriangledown_{\omega} E_{s \sim \rho^{\pi_\theta} , a \sim \pi_\theta} \left[(Q^{\omega}(s,a) - Q^{\pi}(s,a)^2)\right]$, where $Q^{\pi}$ is the true action-value. In contrast to using $Q^{\pi}$, using $Q^{\omega}$ may introduce bias but can reduce deviation effectively.</p><h4 id="Off-Policy-Actor-Critic"><a href="#Off-Policy-Actor-Critic" class="headerlink" title="Off-Policy Actor-Critic"></a>Off-Policy Actor-Critic</h4><p>In an off-policy setting, we can easily train the critic by using the temporal-difference error, however some modification is required for the estimation of the policy gradient.</p><p>The performance objective is modified to be the value function of the target policy $\pi$, averaged over the state distribution of the behavior policy $\beta$:</p><script type="math/tex; mode=display">\begin{align*}J_{\beta}(\pi_{\theta}) & = \int_{S} \rho^{\beta}(s)V^{\pi}(s)ds\\ & = \int_{S}\int_{A} \rho^{\beta}(s)\pi_{\theta}(a|s)Q^{\pi}(s,a)dads.\end{align*}\tag{2}</script><p>Differentiating above objective and applying an approximation gives the off-policy-gradient:</p><script type="math/tex; mode=display">\begin{align*}\bigtriangledown_{\theta}J_{\beta}(\pi_{\theta})& \approx\int_{S}\int_{A} \rho^{\beta}(s)\bigtriangledown_{\theta}\pi_{\theta}(a|s)Q^{\pi}(s,a)dads\\& =E_{s \sim \rho^{\beta}, a \sim \beta}\left[\frac{\pi_{\theta}(a|s)}{\beta_{\theta}(a|s)}\bigtriangledown_{\theta}log\pi_{\theta}(a|s)Q^{\pi}(s,a)\right]\end{align*}\tag{3}</script><p>Though the approximation drops a term that depends on the action-value gradient $\bigtriangledown_{\theta}Q^{\pi}(s,a)$, it is a good approximation since it can preserve the set of local optima to which gradient ascent converges. Note that the true action-value is unknown so we must use an estimator $V^v$ to approximate $V^{\pi}$and use the temporal-difference $r(s,a) + \gamma V^{v}(s’)$ to approximate $Q^{\pi}(s,a)$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Q-Network (DQN)</title>
      <link href="/2021/02/01/Deep-Q-Network-DQN/"/>
      <url>/2021/02/01/Deep-Q-Network-DQN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://storage.googleapis.com/deepmind-media/dqn/DQNNaturePaper.pdf">Paper Link</a></p><p>Deep Q-Network (DQN) can be regarded as the first algorithm which effectively combines reinforcement learning (RL) with deep learning (DL). Specifically, it address two main issues that hinder the combination of RL and DL: <strong>one is that in reinforcement learning an agent typically encounters sequences of highly correlated states; the other is that the learning target is constantly changed since the policy of agent is continuously updated.</strong></p><h2 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h2><p>Most deep learning algorithms require the data samples to be independent while in reinforment learning the data used for training are usually successive transitions which have high correlation. To alleviate the problems of correlated data, <strong>DQN utilizes an experience replay mechanism which stores a mass of transitions and these transitions will be randomly sampled for training the neural network.</strong> This idea is quite simple but effectively breaks the correlation of training data. The process is illustrated in Figure 1.</p><div style="width:70%;margin:auto">  <img src="/2021/02/01/Deep-Q-Network-DQN/1.png" class="" title="Figure 1"></div><p>As shown in Figure 1, transitions $(s, r, s’)$ are stored in experience replay memory when the agent interacts with the environment and meanwhile a  random minibatch of experiences $(s, a, r, s’)$ are sampled from the memory for training the network.</p><h2 id="Target-Network"><a href="#Target-Network" class="headerlink" title="Target Network"></a>Target Network</h2><p>The objective for training Q-Network (with weights $\theta$) is:</p><script type="math/tex; mode=display">L(\theta) = E_{s, a\sim\rho(\cdot)}[(y - Q_{\theta}(s, a, \theta))^2],</script><p>where $y = r(s, a, s’) + \gamma max_{a’}Q_{\theta}(s’, a’)$. Apparently, the target $y_i$ is constantly changed with the updating of the Q-Network, which makes the update unstable. To solve the non-stationarity of the targets, they use the old version of  Q-Network (with weights $\theta’$) to compute the targets , namely $y = r(s, a, s’) + \gamma max_{a’}Q_{\theta’}(s’, a’)$ and copy $\theta$ to $\theta’$ periodically. This can make the targets stay constant for a long period of time.</p><h2 id="Pseudocode-of-DQN"><a href="#Pseudocode-of-DQN" class="headerlink" title="Pseudocode of DQN"></a>Pseudocode of DQN</h2><p>With the two main ideas mentioned above, the pseudocode of DQN is shown below:</p><hr><p>&emsp;Initialize value network $Q_\theta$ with random weights</p><p>&emsp;Copy $Q_\theta$ to create the target network $Q_{\theta’}$</p><p>&emsp;Initialize experience replay memory $D$ of maximal size $N$</p><p>&emsp;Observe the initial state $s_0$</p><p>&emsp;for $t\in[0, T_{total}]$:</p><p>&emsp;&emsp;&emsp;&emsp;With probability $\epsilon$ select a random action $a_t$ based on the behavior policy derived from $Q_\theta(s_t, a)$</p><p>&emsp;&emsp;&emsp;&emsp;Execute action $a_t$ in emulator and observe reward $r_t$ and next state $s_{t+1}$</p><p>&emsp;&emsp;&emsp;&emsp;Store $(s_t, a_t, r_t, s_{t+1})$ in $D$</p><p>&emsp;&emsp;&emsp;&emsp;Every $T_{train}$ steps:</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Sample a minibatch $D_s$ randomly form $D$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;For each transition $(s, a, r, s’)$ in the minibatch:</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Predict the Q-value of the greedy action in the next state $max_{a’}Q_{\theta’}(s’, a’)$ using the target network.</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Compute the target value $y = r(s, a, s’) + \gamma max_{a’}Q_{\theta’}(s’, a’)$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Train the value network $Q_{\theta}$ on $D_{s}$ to minimize $L(\theta)s = E_{D_s}[(y - Q_{\theta}(s, a, \theta))^2]$</p><p>&emsp;&emsp;&emsp;&emsp;Every $T_{target}$ steps:</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Update the target network with the trained value network: $\theta’\leftarrow\theta$</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程(三)：项目的分支</title>
      <link href="/2020/09/23/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2020/09/23/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h2><p>首先我们从人的角度来理解分支，分支就是一个项目的不同版本，即对于同一个项目，不同的人给项目添加不同的模块，那么每个人都会让项目产生一个不同的版本，即各种分支，如下图所示：</p><p><img src="1.svg" alt=""></p><p>中间绿线代表主分支的时间线，主分支通常为发行版本，橙色和蓝色分支分别是开发分支，例如张三和李四分别负责为A版本(发行版本)的项目添加一个新的模块，那么他们就会从主分支A结点分裂出两个分支，他们分别在各自的分支上开发，然后开发完毕后，在C结点合并到主分支，这时候C版本(发行版本)的项目就具备了张三和李四新开发的功能。</p><h2 id="分支的工作原理"><a href="#分支的工作原理" class="headerlink" title="分支的工作原理*"></a>分支的工作原理*</h2><p>在之前的描述中，可能大家会认为，每创建一个分支，Git都会像上图那样，从主分支的时间线上分裂出一个新的分支时间线，可事实并非如此：Git从始至终只会存在一条时间线，而不同的分支只是以指针的形式存在，我们借助示意图来分析：</p><ol><li>最开始时间线上只有一个master分支，<strong>注意，时间线有且只有一条，并且时间线上每一个节点都代表一次提交(commit)</strong>。开始的时间上只涉及到两个指针，HEAD和master指针，其中HEAD指向当前分支，master指向提交。</li></ol><p><img src="2.svg" alt=""></p><ol><li>接着我们创建一个新的dev分支，这个时候，Git会创建一个dev指针，并使其直接指向当前提交节点，而我们又发现，当前提交节点不就是master指针指向的吗？所以Git会直接将master指针的值赋给dev指针，下一步，如果我们切换到dev分支，HEAD会指向dev(因为HEAD指针指向当前分支)。</li></ol><p><img src="3.svg" alt=""></p><ol><li>我们在dev分支上修改项目，并进行下一次提交，此时dev指针向前移动一步(因为分支指针指向提交)，又因为HEAD指针指向当前分支(dev)，所以HEAD指针也会跟着向前移动一步。</li></ol><p><img src="4.svg" alt=""></p><ol><li>如果需要将dev分支合并到主分支，只需要将master指针前移，即将dev指针的值赋给master，再切换到主分支，HEAD指针指向master。</li></ol><p><img src="5.svg" alt=""></p><ol><li>若要删除dev分支，只需要直接删除dev指针即可。</li></ol><h2 id="管理分支的命令"><a href="#管理分支的命令" class="headerlink" title="管理分支的命令"></a>管理分支的命令</h2><ol><li>查看现有分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><ol><li>创建分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 &#x2F;&#x2F;建议英文，不需要加引号</span><br></pre></td></tr></table></figure><ol><li>切换分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><ol><li>合并分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名  &#x2F;&#x2F;会把指定分支合并到你当前所在的分支</span><br></pre></td></tr></table></figure><ol><li>删除分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><h2 id="合并分支的冲突问题"><a href="#合并分支的冲突问题" class="headerlink" title="合并分支的冲突问题"></a>合并分支的冲突问题</h2><p>还记得上一篇文中提到的合并冲突问题吗？解决冲突问题需要我们手动操作，Git会指出在合并过程中发生冲突的部分，在命令行中会指出冲突文件，然后我们打开冲突文件内部，会发现Git同样标明了冲突的文本段，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello world！</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">111</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">222</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>指出了发生冲突的部分，我们修改冲突文件，例如修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world！</span><br><span class="line">111</span><br></pre></td></tr></table></figure><p>保存文件，再手动提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 1.txt</span><br><span class="line">git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程(二)：项目的上传与拉取</title>
      <link href="/2020/09/15/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E6%8B%89%E5%8F%96/"/>
      <url>/2020/09/15/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E6%8B%89%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="项目上传"><a href="#项目上传" class="headerlink" title="项目上传"></a>项目上传</h2><p>项目上传，即把本地仓库中的内容上传到远端仓库，主要分为三个步骤：</p><ol><li>将工作区内容添加到暂存区</li></ol><p>由于我们对项目文件的直接操作都是在工作区的，所以第一步要把我们工作区的文件添加到暂存区，这步非常关键，因为如果你的对文件的增删改的变动没有被添加到暂存区的话，这些变动是不能被提交到本地版本库的。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add [参数] &lt;路径&gt;</span><br><span class="line">git add . &#x2F;&#x2F;.代表当前目录，不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到暂存区，注意不包括删除</span><br><span class="line">git add -u . &#x2F;&#x2F;参数-u表示将已跟踪文件中的修改和删除的文件添加到暂存区，注意不包括新增的文件</span><br><span class="line">git add -A . &#x2F;&#x2F;参数-A表示将所有已跟踪文件的修改和删除与新增的未跟踪文件都添加到暂存区</span><br></pre></td></tr></table></figure><p>注：可以通过使用 <strong>git status</strong> 命令查看工作区代码相对于暂存区的差别。</p><ol><li>将暂存区内容提交到本地版本库</li></ol><p>直接上命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;注释&quot; &#x2F;&#x2F;注释一般写本次提交所变更的内容</span><br></pre></td></tr></table></figure><p>commit命令会在本地版本库生成一个40为的哈希值，也叫commit id，同时本地库有一个HEAD文件(指针)，指向最新的commit id(言外之意本地库保存了多个commit id，可以通过HEAD指针的移动来进行版本回退)。</p><ol><li>将本地版本库推送到远程仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>远程主机名一般为origin，本地分支名这个参数通常可以省略，因为省略时默认为你当前所在的本地分支，远程分支名不能省略(关于分支的概念下一节会详细介绍)，由于本地仓库与远程仓库都有一个初始默认分支master，所以大多数教程最常见的命令就是 <strong>git push origin master</strong>(注意这里的master是远程分支名)。push命令执行完后，<strong>远程仓库的指定分支将会被你提交的本地库分支完全覆盖</strong>。</p><h2 id="项目拉取"><a href="#项目拉取" class="headerlink" title="项目拉取"></a>项目拉取</h2><p>项目拉取顾名思义，即将远程库中的内容拉取到本地库中，具体的应用场景为，你的团队人员修改了项目，上传到了远程仓库，你需要接着他的修改继续做，所以你就需要拉取远程仓库的内容到你的本地库。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>同样的，远程主机名一般为origin，本地分支名参数通常可以省略，省略时默认为你当前所在的本地分支，所以常见的命令就是 <strong>git pull origin master</strong>(注意这里的master是远程分支名)。执行完之后，远程仓库指定分支的内容就会被合并(merge)到你指定的本地分支上，<strong>注意，是合并，而不是完全覆盖</strong>。</p><p>你可能会有一些疑问，若是我本地库有一个文件1.txt，远程库有一个新增的文件2.txt，若想合并，只需要将2.txt添加到我的本地库即可，但是如果远程库的更改是在1.txt上的，例如本地库的1.txt中写的是”111”，远程库中的1.txt中写的是“222”，这时候该如何合并？是遵从本地库还是遵从远程库？关于这种冲突的情况在下节中会详细介绍。</p><p>最后再谈一下fetch与merge指令，fetch与pull指令很相似，也是将远程库的内容拉取到本地库，但是却不同，网上很多教程说，pull = fetch + merge，即fetch只是将远程库的内容拉取下来了，但是并没有合并到本地库，也就是说你单纯执行fetch命令，并不会更改本地库的内容，需要进一步执行merge命令，才能将拉取下来的内容合并到本地仓库，其实从更本质的角度来说，<strong>fetch指令只是将本地库所关联的远程库的commit id更新到最新，但本地库并不会发生变化；而pull会更新本地库的HEAD指针，所以能够改变本地库</strong>。<a href="https://blog.csdn.net/a19881029/article/details/42245955">详细解释</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程(一)：简介与初步配置</title>
      <link href="/2020/09/10/Git-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/10/Git-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)，主要为了方便多人协同开发和版本控制。</p><h3 id="Git的组成"><a href="#Git的组成" class="headerlink" title="Git的组成"></a>Git的组成</h3><p>GIt由<strong>本地仓库</strong>与<strong>远程仓库</strong>构成，其中本地仓库由<strong>工作区(workspace)</strong>、<strong>暂存区(stage)</strong>和<strong>版本库(repository)</strong>构成：工作区就是你项目文件夹下的各种文件，这是用户能直接进行添加、修改、删除的操作的地方；暂存区保存了下次将提交到仓库的文件信息列表，用来存储每天一小阶段的工作；版本库保存了你提交的所有版本的数据记录。版本库的内容可以是从本地工作区(从工作区添加到暂存区再到仓库区)提交的，也可以是从远程仓库中拉取下来的。</p><h3 id="Git的工作逻辑"><a href="#Git的工作逻辑" class="headerlink" title="Git的工作逻辑"></a>Git的工作逻辑</h3><p>其工作逻辑如下图所示：</p><p><img src="1.png" alt=""></p><p>举个简单的例子，张三想要与他人合作完成一个项目，首先他需要在GitHub上创建一个项目仓库，然后将仓库clone到在自己的电脑上，于是本地就多了一个项目文件夹，这就是本地仓库，里面有若干文件(初始时应该只有一个README)和.git隐藏文件夹，若干文件构成了工作区，.git文件下就保存了该仓库的信息，包括暂存区(存储在index文件中)与版本库的信息；然后张三每次对于工作区文件的更改，都可以通过指令同步到本地仓库中(首先将更改添加(add)到暂存区，然后再提交(commit)到版本库)，接着张三就可以把本地仓库的内容同步(push)到远程仓库。同样的作为其他开发成员的李四也可以从远程仓库拉取(fetch/clone)项目到自己的本地仓库，李四也可以更改项目并上传远程仓库，这样就可以实现多人合作开发。</p><h2 id="Git的初步配置"><a href="#Git的初步配置" class="headerlink" title="Git的初步配置"></a>Git的初步配置</h2><p>首先我们需要在本地安装Git工具，有了这个工具我们就可以执行Git的各种指令，如何安装可以自行Google/百度，然后我们需要一个远程仓库，通常选择GitHub，在GitHub上注册账号即可，然后我们需要<strong>配置ssh密钥</strong>来完成本机与远程仓库的互联。</p><p>GitHub使用ssh认证，通俗来讲，就是你的本地要想向远程仓库上传或者从其拉取，需要一个认证，而这个认证就是ssh，ssh密钥由公钥和私钥组成，其中公钥要填写到GitHub网站上，私钥保存在本机上，具体操作为：</p><ol><li>在本机执行指令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -C &quot;你的GitHub邮箱&quot;</span><br></pre></td></tr></table></figure><p>这时会在你本机的主目录下生成一个.ssh的文件夹，里面存放了私钥和公钥，其中后缀为.pub为公钥。</p><ol><li>复制公钥里面的内容到GitHub上(在Settings里的SSH and GPG keys选项，点击 New SSH key)</li></ol><p><img src="2.png" alt=""></p><p>填写好title和公钥即可</p><ol><li>在GitHub上新建一个远程仓库(Your repositories里点击new)</li></ol><p><img src="3.png" alt=""></p><p>填写好信息(推荐勾选”Add a README file”)即可创建完成</p><ol><li>将远程仓库拉取到本地</li></ol><p>点击新建好的仓库，然后复制仓库的URL地址</p><p><img src="4.png" alt=""></p><p>在本机上输入指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &quot;你的仓库URL&quot;</span><br></pre></td></tr></table></figure><p>到此为止，我们就完成了远程仓库与本地仓库的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(四)：标注与图例</title>
      <link href="/2020/03/19/Matplotlib-%E6%A0%87%E6%B3%A8%E4%B8%8E%E5%9B%BE%E4%BE%8B/"/>
      <url>/2020/03/19/Matplotlib-%E6%A0%87%E6%B3%A8%E4%B8%8E%E5%9B%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="text标注"><a href="#text标注" class="headerlink" title="text标注"></a>text标注</h2><p>text用于直接在图像中的任意位置进行标注，传入参数包括：<strong>x</strong>，<strong>y</strong>，<strong>s</strong>，<strong>fontsize</strong>，<strong>fontstyle</strong>，<strong>fontweight</strong></p><blockquote><p><strong>x</strong>为横坐标<br><strong>y</strong>为纵坐标<br><strong>s</strong>为标注字符串<br><strong>fontsize/fontstyle/fontweight</strong>为字体设置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(X, y)</span><br><span class="line"></span><br><span class="line">plt.text(x=<span class="number">3.14</span> / <span class="number">2</span>, y=<span class="number">1</span>, s=<span class="string">&#x27;Max&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="1.png" alt=""></p><h2 id="annotate标注"><a href="#annotate标注" class="headerlink" title="annotate标注"></a>annotate标注</h2><p>annotate用于给图像中的某个点进行标注，调用plt.annotate方法即可，传入参数包括：<strong>s</strong>，<strong>xy</strong>，<strong>xytext</strong>，<strong>textcoords</strong>，<strong>fontsize</strong>，<strong>fontstyle</strong>，<strong>fontweight</strong></p><blockquote><p><strong>s</strong>为标注字符串<br><strong>xy</strong>为被标注点位置坐标<br><strong>xytext</strong>为标注文字的坐标(一般与textcoords=’offset points’连用，此时坐标为相对于xy的偏移值)<br><strong>textcoords</strong>一般传入’offset points’<br><strong>fontsize/fontstyle/fontweight</strong>为字体设置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(X, y)</span><br><span class="line"></span><br><span class="line">plt.annotate(s=<span class="string">&#x27;Max&#x27;</span>, xy=(<span class="number">3.14</span> / <span class="number">2</span>, <span class="number">1</span>), xytext=(<span class="number">0</span>, <span class="number">0.1</span>), textcoords=<span class="string">&#x27;offset points&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="1.png" alt=""></p><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>调用plt.legend方法即可给一张figure中的不同曲线添加图例标注，直接传入一个图例名称列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">y1 = np.sin(X)</span><br><span class="line">y2 = np.cos(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(X, y1)</span><br><span class="line">plt.plot(X, y2)</span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(三)：设置坐标轴</title>
      <link href="/2020/03/18/Matplotlib-%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4/"/>
      <url>/2020/03/18/Matplotlib-%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="设置坐标轴区间"><a href="#设置坐标轴区间" class="headerlink" title="设置坐标轴区间"></a>设置坐标轴区间</h2><p>调用plt.xlim与plt.ylim，传入坐标区间元组，即可分别设置x轴与y轴的取值范围<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xlim((<span class="number">-10</span>, <span class="number">10</span>)) <span class="comment">#设置x轴的取值范围为[-10, 10]</span></span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">2</span>)) <span class="comment">#设置y轴的取值范围为[-2, 2]</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="1.png" alt=""></p><h2 id="设置坐标轴名称"><a href="#设置坐标轴名称" class="headerlink" title="设置坐标轴名称"></a>设置坐标轴名称</h2><p>调用plt.xlabel与plt.ylabel，传入字符串，即可分别设置x轴与y轴的名称<br>除名称字符串外，可选参数包括: <strong>fontsize</strong>，<strong>fontweight</strong>，<strong>fontstyle</strong>，<strong>c(color)</strong></p><blockquote><p><strong>fontsize</strong>设置字体大小，取值为正数<br><strong>fontweight</strong>设置字体粗细，可选参数 [‘light’, ‘normal’, ‘medium’, ‘semibold’, ‘bold’, ‘heavy’, ‘black’]<br><strong>fontstyle</strong>设置字体样式，可选参数[ ‘normal’ | ‘italic’ | ‘oblique’ ]，italic斜体，oblique倾斜<br><strong>color</strong>设置字体颜色</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line">plt.xlim((<span class="number">-10</span>, <span class="number">10</span>)</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;value of x&#x27;</span>, fontsize=<span class="number">15</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontstyle=<span class="string">&#x27;italic&#x27;</span>, c=<span class="string">&#x27;g&#x27;</span>) <span class="comment"># 字号15，加粗，斜体，绿色</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;value of y&#x27;</span>, fontsize=<span class="number">15</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontstyle=<span class="string">&#x27;italic&#x27;</span>, c=<span class="string">&#x27;g&#x27;</span>) <span class="comment"># 字号15，加粗，斜体，绿色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="2.png" alt=""></p><h2 id="设置坐标轴刻度"><a href="#设置坐标轴刻度" class="headerlink" title="设置坐标轴刻度"></a>设置坐标轴刻度</h2><p>调用plt.xticks，plt.yticks，传入刻度值列表，即可分别设置x轴与y轴刻度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xlim((<span class="number">-10</span>, <span class="number">10</span>))</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.yticks(np.arange(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p><p>在plt.xticks/yticks传入第二个参数即可设置刻度别名，该参数为刻度值别名列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">1</span>, <span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xticks(np.arange(<span class="number">1</span>, <span class="number">13</span>, <span class="number">1</span>), [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(二)：基本绘图</title>
      <link href="/2020/03/17/Matplotlib-%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/03/17/Matplotlib-%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="绘制线条"><a href="#绘制线条" class="headerlink" title="绘制线条"></a>绘制线条</h2><p>最基本的绘图为线条的绘制，调用plt.plot方法即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.plot(x_list, y_list)， x_list为x轴取值列表， y_list为y轴取值列表，列表中的元素一一对应。</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>plt.plot也有一些额外的修饰参数，包括：<strong>c(color)</strong>，<strong>ls(linestyle)</strong>，<strong>lw(linewidth)</strong>，<strong>marker</strong></p><blockquote><p><strong>color参数可选项：</strong><a href="https:// blog.csdn.net/mmc2015/article/details/72829107" title="color参数">https://blog.csdn.net/mmc2015/article/details/72829107</a></p><p><strong>linestyle参数可选项：</strong><br>‘-‘       solid line style<br>‘—‘      dashed line style<br>‘-.’      dash-dot line style<br>‘:’       dotted line style</p><p><strong>linewidth：</strong>直接输入一个正数值即可</p><p><strong>marker参数可选项：</strong><br>‘.’       point marker<br>‘,’       pixel marker<br>‘o’       circle marker<br>‘v’       triangle_down marker<br>‘^’       triangle_up marker<br>‘&lt;’       triangle_left marker<br>‘&gt;’       triangle_right marker<br>‘1’       tri_down marker<br>‘2’       tri_up marker<br>‘3’       tri_left marker<br>‘4’       tri_right marker<br>‘s’       square marker<br>‘p’       pentagon marker<br>‘*’       star marker<br>‘h’       hexagon1 marker<br>‘H’       hexagon2 marker<br>‘+’       plus marker<br>‘x’       x marker<br>‘D’       diamond marker<br>‘d’       thin_diamond marker<br>‘|’       vline marker<br>‘_’       hline marker</p></blockquote><p>调用时也可以组合参数，比如我们需要<strong>绿色</strong>、<strong>dashed line</strong>、<strong>o型标记</strong>，即可传参’go—‘<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;go--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="1.png" alt=""></p><h2 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h2><p>绘制散点图的传参与绘制线图基本一致，调用plt.scatter方法即可，只不过显示出来为散点，并且多了一个<strong>s</strong>参数可以设置点的粗细<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">T = np.arctan2(Y,X) <span class="comment"># color value</span></span><br><span class="line">plt.scatter(X, Y, c=T, s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="2.png" alt=""></p><h2 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h2><p>绘制条形图调用plt.bar方法，上面两种绘图不同的是，设置颜色要用fc(facecolor)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.bar([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>], fc=<span class="string">&#x27;#9999ff&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;3.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(一)：图像创建与保存</title>
      <link href="/2020/03/16/Matplotlib-%E5%9B%BE%E5%83%8F%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BF%9D%E5%AD%98/"/>
      <url>/2020/03/16/Matplotlib-%E5%9B%BE%E5%83%8F%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="创建一个简单图像"><a href="#创建一个简单图像" class="headerlink" title="创建一个简单图像"></a>创建一个简单图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 接下来直接绘图即可</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 调用show方法显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="1.png" alt=""><br>还可设置图像分辨率与图像大小<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(dpi=<span class="number">800</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><h2 id="创建多图像"><a href="#创建多图像" class="headerlink" title="创建多图像"></a>创建多图像</h2><p>方法一：subplot创建子图像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.subplot(row_num, column_num, index)</span></span><br><span class="line"><span class="comment"># 三个参数分别代表总行数，总列数，和接下来想要绘图的子图位置索引(从左到右，从上到下，从1开始标号)</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><br><img src="2.png" alt=""><br>方法二：plt.subplots创建子图像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(row_num, column_num)</span><br><span class="line"><span class="comment"># 该方法一次性创建指定数量的子图，若想在某个子图上绘图，直接通过axes[i, j]索引指定</span></span><br><span class="line">fig, axes = subplots(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p><h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;1.png&#x27;</span>)</span><br><span class="line"><span class="comment"># 也可以在保存的时候指定分辨率</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;1.png&#x27;</span>, dpi=<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：savefig一定要在plt.show()之前调用，否则会保存空白图片</strong></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
