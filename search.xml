<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deep Q-Network (DQN)</title>
      <link href="/2021/02/01/Deep-Q-Network-DQN/"/>
      <url>/2021/02/01/Deep-Q-Network-DQN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://storage.googleapis.com/deepmind-media/dqn/DQNNaturePaper.pdf">Paper Link</a></p><p>Deep Q-Network (DQN) can be regarded as the first algorithm which effectively combines reinforcement learning (RL) with deep learning (DL). Specifically, it address two main issues that hinder the combination of RL and DL: <strong>one is that in reinforcement learning an agent typically encounters sequences of highly correlated states; the other is that the learning target is constantly changed since the policy of agent is continuously updated.</strong></p><h2 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h2><p>Most deep learning algorithms require the data samples to be independent while in reinforment learning the data used for training are usually successive transitions which have high correlation. To alleviate the problems of correlated data, <strong>DQN utilizes an experience replay mechanism which stores a mass of transitions and these transitions will be randomly sampled for training the neural network.</strong> This idea is quite simple but effectively breaks the correlation of training data. The process is illustrated in Figure 1.</p><div style="width:70%;margin:auto">  <img src="/2021/02/01/Deep-Q-Network-DQN/1.png" class="" title="Figure 1"></div><p>As shown in Figure 1, transitions $(s, r, s’)$ are stored in experience replay memory when the agent interacts with the environment and meanwhile a  random minibatch of experiences $(s, a, r, s’)$ are sampled from the memory for training the network.</p><h2 id="Target-Network"><a href="#Target-Network" class="headerlink" title="Target Network"></a>Target Network</h2><p>The objective for training Q-Network (with weights $\theta$) is:</p><script type="math/tex; mode=display">L(\theta) = E_{s, a\sim\rho(\cdot)}[(y - Q_{\theta}(s, a, \theta))^2],</script><p>where $y = r(s, a, s’) + \gamma max_{a’}Q_{\theta}(s’, a’)$. Apparently, the target $y_i$ is constantly changed with the updating of the Q-Network, which makes the update unstable. To solve the non-stationarity of the targets, they use the old version of  Q-Network (with weights $\theta’$) to compute the targets , namely $y = r(s, a, s’) + \gamma max_{a’}Q_{\theta’}(s’, a’)$ and copy $\theta$ to $\theta’$ periodically. This can make the targets stay constant for a long period of time.</p><h2 id="Pseudocode-of-DQN"><a href="#Pseudocode-of-DQN" class="headerlink" title="Pseudocode of DQN"></a>Pseudocode of DQN</h2><p>With the two main ideas mentioned above, the pseudocode of DQN is shown below:</p><hr><p>&emsp;Initialize value network $Q_\theta$ with random weights</p><p>&emsp;Copy $Q_\theta$ to create the target network $Q_{\theta’}$</p><p>&emsp;Initialize experience replay memory $D$ of maximal size $N$</p><p>&emsp;Observe the initial state $s_0$</p><p>&emsp;for $t\in[0, T_{total}]$:</p><p>&emsp;&emsp;&emsp;&emsp;With probability $\epsilon$ select a random action $a_t$ based on the behavior policy derived from $Q_\theta(s_t, a)$</p><p>&emsp;&emsp;&emsp;&emsp;Execute action $a_t$ in emulator and observe reward $r_t$ and next state $s_{t+1}$</p><p>&emsp;&emsp;&emsp;&emsp;Store $(s_t, a_t, r_t, s_{t+1})$ in $D$</p><p>&emsp;&emsp;&emsp;&emsp;Every $T_{train}$ steps:</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Sample a minibatch $D_s$ randomly form $D$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;For each transition $(s, a, r, s’)$ in the minibatch:</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Predict the Q-value of the greedy action in the next state $max_{a’}Q_{\theta’}(s’, a’)$ using the target network.</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Compute the target value $y = r(s, a, s’) + \gamma max_{a’}Q_{\theta’}(s’, a’)$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Train the value network $Q_{\theta}$ on $D_{s}$ to minimize $L(\theta)s = E_{D_s}[(y - Q_{\theta}(s, a, \theta))^2]$</p><p>&emsp;&emsp;&emsp;&emsp;Every $T_{target}$ steps:</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Update the target network with the trained value network: $\theta’\leftarrow\theta$</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程(三)：项目的分支</title>
      <link href="/2020/09/23/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2020/09/23/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="分支的概念"><a href="#分支的概念" class="headerlink" title="分支的概念"></a>分支的概念</h2><p>首先我们从人的角度来理解分支，分支就是一个项目的不同版本，即对于同一个项目，不同的人给项目添加不同的模块，那么每个人都会让项目产生一个不同的版本，即各种分支，如下图所示：</p><p><img src="1.svg" alt=""></p><p>中间绿线代表主分支的时间线，主分支通常为发行版本，橙色和蓝色分支分别是开发分支，例如张三和李四分别负责为A版本(发行版本)的项目添加一个新的模块，那么他们就会从主分支A结点分裂出两个分支，他们分别在各自的分支上开发，然后开发完毕后，在C结点合并到主分支，这时候C版本(发行版本)的项目就具备了张三和李四新开发的功能。</p><h2 id="分支的工作原理"><a href="#分支的工作原理" class="headerlink" title="分支的工作原理*"></a>分支的工作原理*</h2><p>在之前的描述中，可能大家会认为，每创建一个分支，Git都会像上图那样，从主分支的时间线上分裂出一个新的分支时间线，可事实并非如此：Git从始至终只会存在一条时间线，而不同的分支只是以指针的形式存在，我们借助示意图来分析：</p><ol><li>最开始时间线上只有一个master分支，<strong>注意，时间线有且只有一条，并且时间线上每一个节点都代表一次提交(commit)</strong>。开始的时间上只涉及到两个指针，HEAD和master指针，其中HEAD指向当前分支，master指向提交。</li></ol><p><img src="2.svg" alt=""></p><ol><li>接着我们创建一个新的dev分支，这个时候，Git会创建一个dev指针，并使其直接指向当前提交节点，而我们又发现，当前提交节点不就是master指针指向的吗？所以Git会直接将master指针的值赋给dev指针，下一步，如果我们切换到dev分支，HEAD会指向dev(因为HEAD指针指向当前分支)。</li></ol><p><img src="3.svg" alt=""></p><ol><li>我们在dev分支上修改项目，并进行下一次提交，此时dev指针向前移动一步(因为分支指针指向提交)，又因为HEAD指针指向当前分支(dev)，所以HEAD指针也会跟着向前移动一步。</li></ol><p><img src="4.svg" alt=""></p><ol><li>如果需要将dev分支合并到主分支，只需要将master指针前移，即将dev指针的值赋给master，再切换到主分支，HEAD指针指向master。</li></ol><p><img src="5.svg" alt=""></p><ol><li>若要删除dev分支，只需要直接删除dev指针即可。</li></ol><h2 id="管理分支的命令"><a href="#管理分支的命令" class="headerlink" title="管理分支的命令"></a>管理分支的命令</h2><ol><li>查看现有分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><ol><li>创建分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名 &#x2F;&#x2F;建议英文，不需要加引号</span><br></pre></td></tr></table></figure><ol><li>切换分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><ol><li>合并分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名  &#x2F;&#x2F;会把指定分支合并到你当前所在的分支</span><br></pre></td></tr></table></figure><ol><li>删除分支</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><h2 id="合并分支的冲突问题"><a href="#合并分支的冲突问题" class="headerlink" title="合并分支的冲突问题"></a>合并分支的冲突问题</h2><p>还记得上一篇文中提到的合并冲突问题吗？解决冲突问题需要我们手动操作，Git会指出在合并过程中发生冲突的部分，在命令行中会指出冲突文件，然后我们打开冲突文件内部，会发现Git同样标明了冲突的文本段，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello world！</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">111</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">222</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>指出了发生冲突的部分，我们修改冲突文件，例如修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world！</span><br><span class="line">111</span><br></pre></td></tr></table></figure><p>保存文件，再手动提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add 1.txt</span><br><span class="line">git commit -m &quot;conflict fixed&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程(二)：项目的上传与拉取</title>
      <link href="/2020/09/15/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E6%8B%89%E5%8F%96/"/>
      <url>/2020/09/15/Git-%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E6%8B%89%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="项目上传"><a href="#项目上传" class="headerlink" title="项目上传"></a>项目上传</h2><p>项目上传，即把本地仓库中的内容上传到远端仓库，主要分为三个步骤：</p><ol><li>将工作区内容添加到暂存区</li></ol><p>由于我们对项目文件的直接操作都是在工作区的，所以第一步要把我们工作区的文件添加到暂存区，这步非常关键，因为如果你的对文件的增删改的变动没有被添加到暂存区的话，这些变动是不能被提交到本地版本库的。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add [参数] &lt;路径&gt;</span><br><span class="line">git add . &#x2F;&#x2F;.代表当前目录，不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到暂存区，注意不包括删除</span><br><span class="line">git add -u . &#x2F;&#x2F;参数-u表示将已跟踪文件中的修改和删除的文件添加到暂存区，注意不包括新增的文件</span><br><span class="line">git add -A . &#x2F;&#x2F;参数-A表示将所有已跟踪文件的修改和删除与新增的未跟踪文件都添加到暂存区</span><br></pre></td></tr></table></figure><p>注：可以通过使用 <strong>git status</strong> 命令查看工作区代码相对于暂存区的差别。</p><ol><li>将暂存区内容提交到本地版本库</li></ol><p>直接上命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;注释&quot; &#x2F;&#x2F;注释一般写本次提交所变更的内容</span><br></pre></td></tr></table></figure><p>commit命令会在本地版本库生成一个40为的哈希值，也叫commit id，同时本地库有一个HEAD文件(指针)，指向最新的commit id(言外之意本地库保存了多个commit id，可以通过HEAD指针的移动来进行版本回退)。</p><ol><li>将本地版本库推送到远程仓库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>远程主机名一般为origin，本地分支名这个参数通常可以省略，因为省略时默认为你当前所在的本地分支，远程分支名不能省略(关于分支的概念下一节会详细介绍)，由于本地仓库与远程仓库都有一个初始默认分支master，所以大多数教程最常见的命令就是 <strong>git push origin master</strong>(注意这里的master是远程分支名)。push命令执行完后，<strong>远程仓库的指定分支将会被你提交的本地库分支完全覆盖</strong>。</p><h2 id="项目拉取"><a href="#项目拉取" class="headerlink" title="项目拉取"></a>项目拉取</h2><p>项目拉取顾名思义，即将远程库中的内容拉取到本地库中，具体的应用场景为，你的团队人员修改了项目，上传到了远程仓库，你需要接着他的修改继续做，所以你就需要拉取远程仓库的内容到你的本地库。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>同样的，远程主机名一般为origin，本地分支名参数通常可以省略，省略时默认为你当前所在的本地分支，所以常见的命令就是 <strong>git pull origin master</strong>(注意这里的master是远程分支名)。执行完之后，远程仓库指定分支的内容就会被合并(merge)到你指定的本地分支上，<strong>注意，是合并，而不是完全覆盖</strong>。</p><p>你可能会有一些疑问，若是我本地库有一个文件1.txt，远程库有一个新增的文件2.txt，若想合并，只需要将2.txt添加到我的本地库即可，但是如果远程库的更改是在1.txt上的，例如本地库的1.txt中写的是”111”，远程库中的1.txt中写的是“222”，这时候该如何合并？是遵从本地库还是遵从远程库？关于这种冲突的情况在下节中会详细介绍。</p><p>最后再谈一下fetch与merge指令，fetch与pull指令很相似，也是将远程库的内容拉取到本地库，但是却不同，网上很多教程说，pull = fetch + merge，即fetch只是将远程库的内容拉取下来了，但是并没有合并到本地库，也就是说你单纯执行fetch命令，并不会更改本地库的内容，需要进一步执行merge命令，才能将拉取下来的内容合并到本地仓库，其实从更本质的角度来说，<strong>fetch指令只是将本地库所关联的远程库的commit id更新到最新，但本地库并不会发生变化；而pull会更新本地库的HEAD指针，所以能够改变本地库</strong>。<a href="https://blog.csdn.net/a19881029/article/details/42245955">详细解释</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程(一)：简介与初步配置</title>
      <link href="/2020/09/10/Git-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/10/Git-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%9D%E6%AD%A5%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)，主要为了方便多人协同开发和版本控制。</p><h3 id="Git的组成"><a href="#Git的组成" class="headerlink" title="Git的组成"></a>Git的组成</h3><p>GIt由<strong>本地仓库</strong>与<strong>远程仓库</strong>构成，其中本地仓库由<strong>工作区(workspace)</strong>、<strong>暂存区(stage)</strong>和<strong>版本库(repository)</strong>构成：工作区就是你项目文件夹下的各种文件，这是用户能直接进行添加、修改、删除的操作的地方；暂存区保存了下次将提交到仓库的文件信息列表，用来存储每天一小阶段的工作；版本库保存了你提交的所有版本的数据记录。版本库的内容可以是从本地工作区(从工作区添加到暂存区再到仓库区)提交的，也可以是从远程仓库中拉取下来的。</p><h3 id="Git的工作逻辑"><a href="#Git的工作逻辑" class="headerlink" title="Git的工作逻辑"></a>Git的工作逻辑</h3><p>其工作逻辑如下图所示：</p><p><img src="1.png" alt=""></p><p>举个简单的例子，张三想要与他人合作完成一个项目，首先他需要在GitHub上创建一个项目仓库，然后将仓库clone到在自己的电脑上，于是本地就多了一个项目文件夹，这就是本地仓库，里面有若干文件(初始时应该只有一个README)和.git隐藏文件夹，若干文件构成了工作区，.git文件下就保存了该仓库的信息，包括暂存区(存储在index文件中)与版本库的信息；然后张三每次对于工作区文件的更改，都可以通过指令同步到本地仓库中(首先将更改添加(add)到暂存区，然后再提交(commit)到版本库)，接着张三就可以把本地仓库的内容同步(push)到远程仓库。同样的作为其他开发成员的李四也可以从远程仓库拉取(fetch/clone)项目到自己的本地仓库，李四也可以更改项目并上传远程仓库，这样就可以实现多人合作开发。</p><h2 id="Git的初步配置"><a href="#Git的初步配置" class="headerlink" title="Git的初步配置"></a>Git的初步配置</h2><p>首先我们需要在本地安装Git工具，有了这个工具我们就可以执行Git的各种指令，如何安装可以自行Google/百度，然后我们需要一个远程仓库，通常选择GitHub，在GitHub上注册账号即可，然后我们需要<strong>配置ssh密钥</strong>来完成本机与远程仓库的互联。</p><p>GitHub使用ssh认证，通俗来讲，就是你的本地要想向远程仓库上传或者从其拉取，需要一个认证，而这个认证就是ssh，ssh密钥由公钥和私钥组成，其中公钥要填写到GitHub网站上，私钥保存在本机上，具体操作为：</p><ol><li>在本机执行指令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -C &quot;你的GitHub邮箱&quot;</span><br></pre></td></tr></table></figure><p>这时会在你本机的主目录下生成一个.ssh的文件夹，里面存放了私钥和公钥，其中后缀为.pub为公钥。</p><ol><li>复制公钥里面的内容到GitHub上(在Settings里的SSH and GPG keys选项，点击 New SSH key)</li></ol><p><img src="2.png" alt=""></p><p>填写好title和公钥即可</p><ol><li>在GitHub上新建一个远程仓库(Your repositories里点击new)</li></ol><p><img src="3.png" alt=""></p><p>填写好信息(推荐勾选”Add a README file”)即可创建完成</p><ol><li>将远程仓库拉取到本地</li></ol><p>点击新建好的仓库，然后复制仓库的URL地址</p><p><img src="4.png" alt=""></p><p>在本机上输入指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &quot;你的仓库URL&quot;</span><br></pre></td></tr></table></figure><p>到此为止，我们就完成了远程仓库与本地仓库的初始化。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(四)：标注与图例</title>
      <link href="/2020/03/19/Matplotlib-%E6%A0%87%E6%B3%A8%E4%B8%8E%E5%9B%BE%E4%BE%8B/"/>
      <url>/2020/03/19/Matplotlib-%E6%A0%87%E6%B3%A8%E4%B8%8E%E5%9B%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="text标注"><a href="#text标注" class="headerlink" title="text标注"></a>text标注</h2><p>text用于直接在图像中的任意位置进行标注，传入参数包括：<strong>x</strong>，<strong>y</strong>，<strong>s</strong>，<strong>fontsize</strong>，<strong>fontstyle</strong>，<strong>fontweight</strong></p><blockquote><p><strong>x</strong>为横坐标<br><strong>y</strong>为纵坐标<br><strong>s</strong>为标注字符串<br><strong>fontsize/fontstyle/fontweight</strong>为字体设置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(X, y)</span><br><span class="line"></span><br><span class="line">plt.text(x=<span class="number">3.14</span> / <span class="number">2</span>, y=<span class="number">1</span>, s=<span class="string">&#x27;Max&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="1.png" alt=""></p><h2 id="annotate标注"><a href="#annotate标注" class="headerlink" title="annotate标注"></a>annotate标注</h2><p>annotate用于给图像中的某个点进行标注，调用plt.annotate方法即可，传入参数包括：<strong>s</strong>，<strong>xy</strong>，<strong>xytext</strong>，<strong>textcoords</strong>，<strong>fontsize</strong>，<strong>fontstyle</strong>，<strong>fontweight</strong></p><blockquote><p><strong>s</strong>为标注字符串<br><strong>xy</strong>为被标注点位置坐标<br><strong>xytext</strong>为标注文字的坐标(一般与textcoords=’offset points’连用，此时坐标为相对于xy的偏移值)<br><strong>textcoords</strong>一般传入’offset points’<br><strong>fontsize/fontstyle/fontweight</strong>为字体设置</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(X, y)</span><br><span class="line"></span><br><span class="line">plt.annotate(s=<span class="string">&#x27;Max&#x27;</span>, xy=(<span class="number">3.14</span> / <span class="number">2</span>, <span class="number">1</span>), xytext=(<span class="number">0</span>, <span class="number">0.1</span>), textcoords=<span class="string">&#x27;offset points&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="1.png" alt=""></p><h2 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h2><p>调用plt.legend方法即可给一张figure中的不同曲线添加图例标注，直接传入一个图例名称列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">y1 = np.sin(X)</span><br><span class="line">y2 = np.cos(X)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(X, y1)</span><br><span class="line">plt.plot(X, y2)</span><br><span class="line"></span><br><span class="line">plt.legend([<span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="2.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
          <category> Matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(三)：设置坐标轴</title>
      <link href="/2020/03/18/Matplotlib-%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4/"/>
      <url>/2020/03/18/Matplotlib-%E8%AE%BE%E7%BD%AE%E5%9D%90%E6%A0%87%E8%BD%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="设置坐标轴区间"><a href="#设置坐标轴区间" class="headerlink" title="设置坐标轴区间"></a>设置坐标轴区间</h2><p>调用plt.xlim与plt.ylim，传入坐标区间元组，即可分别设置x轴与y轴的取值范围<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xlim((<span class="number">-10</span>, <span class="number">10</span>)) <span class="comment">#设置x轴的取值范围为[-10, 10]</span></span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">2</span>)) <span class="comment">#设置y轴的取值范围为[-2, 2]</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="1.png" alt=""></p><h2 id="设置坐标轴名称"><a href="#设置坐标轴名称" class="headerlink" title="设置坐标轴名称"></a>设置坐标轴名称</h2><p>调用plt.xlabel与plt.ylabel，传入字符串，即可分别设置x轴与y轴的名称<br>除名称字符串外，可选参数包括: <strong>fontsize</strong>，<strong>fontweight</strong>，<strong>fontstyle</strong>，<strong>c(color)</strong></p><blockquote><p><strong>fontsize</strong>设置字体大小，取值为正数<br><strong>fontweight</strong>设置字体粗细，可选参数 [‘light’, ‘normal’, ‘medium’, ‘semibold’, ‘bold’, ‘heavy’, ‘black’]<br><strong>fontstyle</strong>设置字体样式，可选参数[ ‘normal’ | ‘italic’ | ‘oblique’ ]，italic斜体，oblique倾斜<br><strong>color</strong>设置字体颜色</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line">plt.xlim((<span class="number">-10</span>, <span class="number">10</span>)</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&#x27;value of x&#x27;</span>, fontsize=<span class="number">15</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontstyle=<span class="string">&#x27;italic&#x27;</span>, c=<span class="string">&#x27;g&#x27;</span>) <span class="comment"># 字号15，加粗，斜体，绿色</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;value of y&#x27;</span>, fontsize=<span class="number">15</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, fontstyle=<span class="string">&#x27;italic&#x27;</span>, c=<span class="string">&#x27;g&#x27;</span>) <span class="comment"># 字号15，加粗，斜体，绿色</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="2.png" alt=""></p><h2 id="设置坐标轴刻度"><a href="#设置坐标轴刻度" class="headerlink" title="设置坐标轴刻度"></a>设置坐标轴刻度</h2><p>调用plt.xticks，plt.yticks，传入刻度值列表，即可分别设置x轴与y轴刻度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xlim((<span class="number">-10</span>, <span class="number">10</span>))</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">2</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">-10</span>, <span class="number">10</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.yticks(np.arange(<span class="number">-2</span>, <span class="number">2</span>, <span class="number">0.5</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p><p>在plt.xticks/yticks传入第二个参数即可设置刻度别名，该参数为刻度值别名列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">1</span>, <span class="number">12</span>, <span class="number">12</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.xticks(np.arange(<span class="number">1</span>, <span class="number">13</span>, <span class="number">1</span>), [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
          <category> Matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(二)：基本绘图</title>
      <link href="/2020/03/17/Matplotlib-%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/03/17/Matplotlib-%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="绘制线条"><a href="#绘制线条" class="headerlink" title="绘制线条"></a>绘制线条</h2><p>最基本的绘图为线条的绘制，调用plt.plot方法即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.plot(x_list, y_list)， x_list为x轴取值列表， y_list为y轴取值列表，列表中的元素一一对应。</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>plt.plot也有一些额外的修饰参数，包括：<strong>c(color)</strong>，<strong>ls(linestyle)</strong>，<strong>lw(linewidth)</strong>，<strong>marker</strong></p><blockquote><p><strong>color参数可选项：</strong><a href="https:// blog.csdn.net/mmc2015/article/details/72829107" title="color参数">https://blog.csdn.net/mmc2015/article/details/72829107</a></p><p><strong>linestyle参数可选项：</strong><br>‘-‘       solid line style<br>‘—‘      dashed line style<br>‘-.’      dash-dot line style<br>‘:’       dotted line style</p><p><strong>linewidth：</strong>直接输入一个正数值即可</p><p><strong>marker参数可选项：</strong><br>‘.’       point marker<br>‘,’       pixel marker<br>‘o’       circle marker<br>‘v’       triangle<em>down marker<br>‘^’       triangle_up marker<br>‘&lt;’       triangle_left marker<br>‘&gt;’       triangle_right marker<br>‘1’       tri_down marker<br>‘2’       tri_up marker<br>‘3’       tri_left marker<br>‘4’       tri_right marker<br>‘s’       square marker<br>‘p’       pentagon marker<br>‘*’       star marker<br>‘h’       hexagon1 marker<br>‘H’       hexagon2 marker<br>‘+’       plus marker<br>‘x’       x marker<br>‘D’       diamond marker<br>‘d’       thin_diamond marker<br>‘|’       vline marker<br>‘</em>‘       hline marker</p></blockquote><p>调用时也可以组合参数，比如我们需要<strong>绿色</strong>、<strong>dashed line</strong>、<strong>o型标记</strong>，即可传参’go—‘<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;go--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="1.png" alt=""></p><h2 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h2><p>绘制散点图的传参与绘制线图基本一致，调用plt.scatter方法即可，只不过显示出来为散点，并且多了一个<strong>s</strong>参数可以设置点的粗细<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">100</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">T = np.arctan2(Y,X) <span class="comment"># color value</span></span><br><span class="line">plt.scatter(X, Y, c=T, s=<span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="2.png" alt=""></p><h2 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h2><p>绘制条形图调用plt.bar方法，上面两种绘图不同的是，设置颜色要用fc(facecolor)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.bar([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>], fc=<span class="string">&#x27;#9999ff&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&#x27;3.png&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
          <category> Matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matplotlib使用教程(一)：图像创建与保存</title>
      <link href="/2020/03/16/Matplotlib-%E5%9B%BE%E5%83%8F%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BF%9D%E5%AD%98/"/>
      <url>/2020/03/16/Matplotlib-%E5%9B%BE%E5%83%8F%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="创建一个简单图像"><a href="#创建一个简单图像" class="headerlink" title="创建一个简单图像"></a>创建一个简单图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 接下来直接绘图即可</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 调用show方法显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="1.png" alt=""><br>还可设置图像分辨率与图像大小<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(dpi=<span class="number">800</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br></pre></td></tr></table></figure></p><h2 id="创建多图像"><a href="#创建多图像" class="headerlink" title="创建多图像"></a>创建多图像</h2><p>方法一：subplot创建子图像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.subplot(row_num, column_num, index)</span></span><br><span class="line"><span class="comment"># 三个参数分别代表总行数，总列数，和接下来想要绘图的子图位置索引(从左到右，从上到下，从1开始标号)</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><br><img src="2.png" alt=""><br>方法二：plt.subplots创建子图像<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(row_num, column_num)</span><br><span class="line"><span class="comment"># 该方法一次性创建指定数量的子图，若想在某个子图上绘图，直接通过axes[i, j]索引指定</span></span><br><span class="line">fig, axes = subplots(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].plot([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><br><img src="3.png" alt=""></p><h2 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&#x27;1.png&#x27;</span>)</span><br><span class="line"><span class="comment"># 也可以在保存的时候指定分辨率</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;1.png&#x27;</span>, dpi=<span class="number">300</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：savefig一定要在plt.show()之前调用，否则会保存空白图片</strong></p>]]></content>
      
      
      <categories>
          
          <category> python常用库 </category>
          
          <category> Matplotlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
